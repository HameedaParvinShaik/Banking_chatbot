AWSTemplateFormatVersion: 2010-09-09
Transform: AWS::Serverless-2016-10-31
Description: Lex V2 Banking Bot with OTP verification via SES + DynamoDB + ThankYou intent

Parameters:
  SarAppArn:
    Description: ARN of SAR Lex CloudFormation Custom Resource application
    Type: String
    Default: arn:aws:serverlessrepo:us-east-1:777566285978:applications/lex-v2-cfn-cr
  SarAppVersion:
    Description: Semantic version of SAR Lex CloudFormation Custom Resource application
    Type: String
    Default: 0.3.0
  OTPTableName:
    Description: DynamoDB table name for storing OTPs
    Type: String
    Default: "<YOUR_OTP_TABLE_NAME>"
  FromEmail:
    Description: Verified SES sender email
    Type: String
    Default: "<YOUR_EMAIL>"
  ReceiverEmail:
    Description: Receiver email for OTP (for testing/demo)
    Type: String
    Default: "<RECEIVER_EMAIL>"

Globals:
  Function:
    Runtime: python3.12
    Timeout: 10
    MemorySize: 128

Resources:

  LexV2CfnCr:
    Type: AWS::Serverless::Application
    Properties:
      Location:
        ApplicationId: !Ref SarAppArn
        SemanticVersion: !Ref SarAppVersion
      Parameters:
        LogLevel: DEBUG

  LexBotExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-LexBotExecutionRole"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonLexFullAccess
        - arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess
        - arn:aws:iam::aws:policy/AmazonSESFullAccess

  LexBotFunction:
    Type: AWS::Serverless::Function
    Properties:
      Description: Lex Fulfillment Lambda with OTP via SES + DynamoDB + ThankYou
      Handler: lambda_function.lambda_handler
      Role: !GetAtt LexBotExecutionRole.Arn
      Runtime: python3.12
      Timeout: 10
      MemorySize: 128
      Environment:
        Variables:
          OTP_TABLE: !Ref OTPTableName
          FROM_EMAIL: !Ref FromEmail
          RECEIVER_EMAIL: !Ref ReceiverEmail
      InlineCode: |
        import boto3
        import os
        import random
        import time
        import decimal

        OTP_TABLE = os.environ.get('OTP_TABLE', '<YOUR_OTP_TABLE_NAME>')
        FROM_EMAIL = os.environ.get('FROM_EMAIL', '<YOUR_EMAIL>')
        RECEIVER_EMAIL = os.environ.get('RECEIVER_EMAIL', '<RECEIVER_EMAIL>')

        dynamodb = boto3.resource('dynamodb')
        ses = boto3.client('ses', region_name='ap-southeast-2')

        def random_num():
            return decimal.Decimal(random.randrange(1000, 50000)) / 100

        def get_slots(event):
            return event['sessionState']['intent'].get('slots', {})

        def get_slot(event, name):
            s = get_slots(event)
            if s and name in s and s[name] is not None:
                return s[name]['value']['interpretedValue']
            return None

        def get_session(event):
            return event['sessionState'].get('sessionAttributes', {})

        def elicit(event, sess, slot, msg):
            intent = event['sessionState']['intent']
            intent['state'] = "InProgress"
            return {
                'sessionState': {
                    'dialogAction': {'type': 'ElicitSlot', 'slotToElicit': slot},
                    'sessionAttributes': sess,
                    'intent': intent
                },
                'messages': [msg],
            }

        def close(event, sess, state, msg):
            intent = event['sessionState']['intent']
            intent['state'] = state
            return {
                'sessionState': {
                    'sessionAttributes': sess,
                    'dialogAction': {'type': 'Close'},
                    'intent': intent
                },
                'messages': [msg],
            }

        def generate_otp(email=RECEIVER_EMAIL):
            otp = str(random.randint(100000, 999999))
            expires = int(time.time()) + 300
            dynamodb.Table(OTP_TABLE).put_item(Item={'email': email, 'otp': otp, 'expires_at': expires})
            ses.send_email(
                Source=FROM_EMAIL,
                Destination={'ToAddresses': [email]},
                Message={
                    'Subject': {'Data': 'Your BankingBot OTP'},
                    'Body': {'Text': {'Data': f'Your OTP is {otp}. It expires in 5 minutes.'}}
                }
            )
            return otp

        def verify_otp(email, otp_input):
            table = dynamodb.Table(OTP_TABLE)
            res = table.get_item(Key={'email': email})
            if 'Item' not in res:
                return False, "No OTP found. Please request a new one."
            item = res['Item']
            if int(time.time()) > item['expires_at']:
                return False, "OTP expired. Please request again."
            if otp_input != item['otp']:
                return False, "Invalid OTP. Please try again."
            table.delete_item(Key={'email': email})
            return True, "OTP verified."

        def handle_otp(event, sess, otp_slot='otp'):
            otp_input = get_slot(event, otp_slot)
            user_input = event.get('inputTranscript', '').lower()
            table = dynamodb.Table(OTP_TABLE)

            existing_otp_item = table.get_item(Key={'email': RECEIVER_EMAIL}).get('Item')
            otp_valid = existing_otp_item and int(time.time()) <= existing_otp_item['expires_at']

            if 'resend' in user_input or 'send again' in user_input or not otp_valid:
                generate_otp()
                msg = {'contentType': 'PlainText', 'content': f"An OTP has been sent to {RECEIVER_EMAIL}. Please enter it."}
                return elicit(event, sess, otp_slot, msg)

            if not otp_input:
                msg = {'contentType': 'PlainText', 'content': "Enter OTP sent to your email."}
                return elicit(event, sess, otp_slot, msg)

            ok, txt = verify_otp(RECEIVER_EMAIL, otp_input)
            if not ok:
                msg = {'contentType': 'PlainText', 'content': txt + " (Type 'resend' to get a new OTP.)"}
                return elicit(event, sess, otp_slot, msg)

            return None

        def CheckBalance(event):
            sess = get_session(event)
            otp_response = handle_otp(event, sess)
            if otp_response is not None:
                return otp_response
            bal = str(random_num())
            msg = {'contentType': 'PlainText', 'content': f"Your account balance is ${bal}."}
            return close(event, sess, "Fulfilled", msg)

        def Payment(event):
            sess = get_session(event)
            otp_response = handle_otp(event, sess)
            if otp_response is not None:
                return otp_response
            account = get_slot(event, 'accountType') or "your account"
            amount = get_slot(event, 'amount') or "an amount"
            msg = {'contentType': 'PlainText', 'content': f"Payment of ${amount} from {account} completed successfully."}
            return close(event, sess, "Fulfilled", msg)

        def Transfer(event):
            sess = get_session(event)
            otp_response = handle_otp(event, sess)
            if otp_response is not None:
                return otp_response
            from_acc = get_slot(event, 'fromAccount') or "source account"
            to_acc = get_slot(event, 'toAccount') or "destination account"
            amount = get_slot(event, 'amount') or "an amount"
            msg = {'contentType': 'PlainText', 'content': f"${amount} transferred from {from_acc} to {to_acc} successfully."}
            return close(event, sess, "Fulfilled", msg)

        def ThankYou(event):
            sess = get_session(event)
            msg = {'contentType': 'PlainText', 'content': "You're welcome! ðŸ˜Š"}
            return close(event, sess, "Fulfilled", msg)

        def dispatch(event):
            name = event['sessionState']['intent']['name']
            if name == 'CheckBalance': return CheckBalance(event)
            if name == 'Payment': return Payment(event)
            if name == 'Transfer': return Transfer(event)
            if name == 'ThankYou': return ThankYou(event)
            raise Exception(f"Unsupported intent: {name}")

        def lambda_handler(event, context):
            return dispatch(event)
